name: CI/CD Pipeline - Test & Deploy

# Triggers on push to the 'main' branch
on:
  push:
    branches:
      - main

env:
  DOCKER_USERNAME: 2000023946
  DOCKER_IMAGE_NAME: 2000023946/auth-service
  ENV_FILE: .env.test 
  
jobs:
  test-and-deploy:
    runs-on: ubuntu-latest
    
    # Ensures the job only runs if the DOCKER_PASSWORD secret is set

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      # CRITICAL: Step to ensure Docker Compose and Buildx are available
      - name: Setup Docker Buildx and Compose
        uses: docker/setup-buildx-action@v2

      - name: Create .env.test file from Secrets
        # Inject SECRETS from GitHub for the environment file
        run: |
          echo "FLASK_ENV=dev" >> ${{ env.ENV_FILE }}
          echo "DB_USER=${{ secrets.DB_USER }}" >> ${{ env.ENV_FILE }}
          echo "DB_PASS=${{ secrets.DB_PASS }}" >> ${{ env.ENV_FILE }}
          echo "DB_NAME=auth_db" >> ${{ env.ENV_FILE }}
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> ${{ env.ENV_FILE }}
          echo "DB_HOST=db" >> ${{ env.ENV_FILE }}
          echo "REDIS_HOST=cache" >> ${{ env.ENV_FILE }}
          echo "REDIS_PORT=6379" >> ${{ env.ENV_FILE }}

      - name: Run Full Testing and Cleanup Sequence
        run: |
          echo "----------------------------------------------------"
          echo "ðŸš€ STARTING INFRASTRUCTURE..."
          echo "----------------------------------------------------"

          # 1. Start Docker containers (Uses your docker-compose logic)
          docker compose --env-file .env.test up -d --build

          echo "â³ Waiting for Auth Service to launch..."

          RETRIES=0
          sudo apt-get update && sudo apt-get install -y curl
          
          # 2. Wait for the Server (Replicates your loop logic)
          until curl -s -o /dev/null "http://localhost:5000/api/auth/me" || [ $RETRIES -eq 10 ]; do
            sleep 5
            ((RETRIES++))
            echo -n "."
          done
          echo "" 

          if [ $RETRIES -eq 10 ]; then
              echo "âŒ Timeout waiting for Docker! Exiting."
              docker compose logs app
              exit 1
          fi

          echo "âœ… Docker is UP! Running Tests..."

          # 3. Execute Pytest inside the container (Replicates your shell script step 4)
          docker compose exec -T app sh -c "
            export PYTHONUNBUFFERED=1
            pip install pytest-cov || true
            
            # --- EXECUTE PYTEST COMMAND AS IN LOCAL SCRIPT ---
            pytest --cov=src src/tests
          "
          TEST_EXIT_CODE=$?

          echo "----------------------------------------------------"
          echo "ðŸ§¹ CLEANING UP..."
          echo "----------------------------------------------------"

          # 4. Stop Containers (Replicates your cleanup step 6)
          docker compose down -v 2>/dev/null

          # 5. Check status (Replicates your check step 7)
          if [ $TEST_EXIT_CODE -eq 0 ]; then
              echo "âœ… SUCCESS: All tests passed. Proceeding to deploy."
          else
              echo "âŒ FAILURE: Some tests failed. Stopping deployment."
              exit 1
          fi
      
      # The rest of the deployment pipeline runs ONLY IF the previous step exits successfully (0)
      - name: Login to Docker Hub
        if: success()
        uses: docker/login-action@v2
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Build and Push Final Image
        if: success()
        run: |
          echo "--- Pushing ${{ env.DOCKER_IMAGE_NAME }}:latest ---"
          docker build -t ${{ env.DOCKER_IMAGE_NAME }}:latest .
          docker push ${{ env.DOCKER_IMAGE_NAME }}:latest

      - name: Final Cleanup (Safety Net)
        if: always()
        run: |
          # The main cleanup should be done, but this handles edge cases.
          docker compose down -v 2>/dev/null || true