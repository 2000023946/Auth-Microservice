name: CI/CD Pipeline - Test & Deploy

# Triggers on push to the 'main' branch
on:
  push:
    branches:
      - main

env:
  # Replace with your Docker Hub ID
  DOCKER_USERNAME: 2000023946
  DOCKER_IMAGE_NAME: 2000023946/auth-service
  # Use the standard test environment file for secrets
  ENV_FILE: .env.test 
  
jobs:
  test-and-deploy:
    runs-on: ubuntu-latest
    
    # Ensures the job only runs if the secrets needed are available
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Setup Test Environment (using docker-compose)
        # Use a temporary docker-compose file just for CI/CD testing
        run: |
          # Create a dummy .env.test file for the action runner (since it doesn't have your local file)
          echo "FLASK_ENV=dev" >> ${{ env.ENV_FILE }}
          echo "DB_USER=${{ secrets.DB_USER }}" >> ${{ env.ENV_FILE }}
          echo "DB_PASS=${{ secrets.DB_PASS }}" >> ${{ env.ENV_FILE }}
          echo "DB_NAME=auth_db" >> ${{ env.ENV_FILE }}
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> ${{ env.ENV_FILE }}
          
          # Use docker-compose to build the application and start services (db, cache)
          docker-compose -f docker-compose.yml --env-file ${{ env.ENV_FILE }} up -d --build

      - name: Wait for App to be Ready
        # Wait until the web server responds on port 5000
        run: |
          echo "Waiting for web service..."
          # Install curl since it's not always default on all runners
          sudo apt-get update && sudo apt-get install -y curl
          
          # Retry curl connection (10 times max, 5 seconds delay)
          for i in $(seq 1 10); do
            curl -s -o /dev/null http://localhost:5000/api/auth/me && echo "App is UP" && exit 0
            sleep 5
          done
          echo "App did not start in time. Exiting."
          exit 1
        
      - name: Run All Tests (Unit, Integration, Functional)
        # We run the tests *inside* the app container using exec
        # This ensures the tests run in the correct network context
        run: |
          docker-compose -f docker-compose.yml --env-file ${{ env.ENV_FILE }} exec -T app sh -c "
            # Set unbuffered output for visibility
            export PYTHONUNBUFFERED=1
            
            # Install pytest-cov in the container environment if needed (or rely on requirements.txt)
            pip install pytest-cov || true
            
            # Run the full test suite (will exit with failure code if tests fail)
            pytest src/tests/
          "
      
      - name: Login to Docker Hub
        if: success() # Only log in if tests passed
        uses: docker/login-action@v2
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Build and Push Final Image
        if: success() # Only deploy if tests passed
        # Use the standard Docker CLI for simplicity in CI/CD environments
        run: |
          # 1. Build the final image with the tag
          docker build -t ${{ env.DOCKER_IMAGE_NAME }}:latest .
          
          # 2. Push to Docker Hub
          docker push ${{ env.DOCKER_IMAGE_NAME }}:latest

      - name: Cleanup Docker Containers
        # Always run cleanup, even if tests fail
        if: always()
        run: |
          docker-compose -f docker-compose.yml --env-file ${{ env.ENV_FILE }} down -v