name: CI/CD Pipeline - Test & Deploy

# Triggers on push to the 'main' branch
on:
  push:
    branches:
      - main

env:
  # Replace with your Docker Hub ID
  DOCKER_USERNAME: 2000023946
  DOCKER_IMAGE_NAME: 2000023946/auth-service
  # Use the standard test environment file for secrets
  ENV_FILE: .env.test 
  
jobs:
  test-and-deploy:
    runs-on: ubuntu-latest
    
    # Ensures the job only runs if the DOCKER_PASSWORD secret is set
    if: secrets.DOCKER_PASSWORD != '' 

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      # CRITICAL FIX: Step to ensure Docker Compose and Buildx are available on the runner
      - name: Setup Docker Buildx and Compose
        uses: docker/setup-buildx-action@v2

      - name: Setup Test Environment (using docker-compose)
        # Create a temporary .env.test file for the action runner 
        run: |
          echo "FLASK_ENV=dev" >> ${{ env.ENV_FILE }}
          echo "DB_USER=${{ secrets.DB_USER }}" >> ${{ env.ENV_FILE }}
          echo "DB_PASS=${{ secrets.DB_PASS }}" >> ${{ env.ENV_FILE }}
          echo "DB_NAME=auth_db" >> ${{ env.ENV_FILE }}
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> ${{ env.ENV_FILE }}
          
          # Use docker-compose to build the application and start services (db, cache)
          # 'docker compose' is the new command, but the action should handle 'docker-compose'
          docker-compose -f docker-compose.yml --env-file ${{ env.ENV_FILE }} up -d --build

      - name: Wait for App to be Ready
        # Wait until the web server responds on port 5000
        run: |
          echo "Waiting for web service..."
          sudo apt-get update && sudo apt-get install -y curl
          
          # Retry curl connection to ensure the app is listening
          for i in $(seq 1 10); do
            curl -s -o /dev/null http://localhost:5000/api/auth/me && echo "App is UP" && exit 0
            sleep 5
          done
          echo "App did not start in time. Exiting."
          exit 1
        
      - name: Run All Tests (Unit, Integration, Functional)
        # Run tests *inside* the app container
        run: |
          docker-compose -f docker-compose.yml --env-file ${{ env.ENV_FILE }} exec -T app sh -c "
            export PYTHONUNBUFFERED=1
            pip install pytest-cov || true
            pytest src/tests/
          "
      
      - name: Login to Docker Hub
        if: success()
        uses: docker/login-action@v2
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Build and Push Final Image (Only if Tests Passed)
        if: success()
        run: |
          # 1. Build the final image with the 'latest' tag
          docker build -t ${{ env.DOCKER_IMAGE_NAME }}:latest .
          
          # 2. Push to Docker Hub
          docker push ${{ env.DOCKER_IMAGE_NAME }}:latest

      - name: Cleanup Docker Containers
        # Always run cleanup, even if tests fail
        if: always()
        run: |
          docker-compose -f docker-compose.yml --env-file ${{ env.ENV_FILE }} down -v