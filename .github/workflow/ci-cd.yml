name: CI/CD Pipeline - Test & Deploy

# Triggers on push to the 'main' branch
on:
  push:
    branches:
      - main

env:
  # Replace with your Docker Hub ID
  DOCKER_USERNAME: 2000023946
  DOCKER_IMAGE_NAME: 2000023946/auth-service
  ENV_FILE: .env.test 
  
jobs:
  test-and-deploy:
    runs-on: ubuntu-latest
    
    # Ensures the job only runs if the DOCKER_PASSWORD secret is set

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      # CRITICAL: Step to ensure Docker Compose and Buildx are available
      - name: Setup Docker Buildx and Compose
        uses: docker/setup-buildx-action@v2

      - name: Create .env.test file from Secrets
        run: |
          # Inject SECRETS from GitHub for the environment file
          echo "FLASK_ENV=dev" >> ${{ env.ENV_FILE }}
          echo "DB_USER=${{ secrets.DB_USER }}" >> ${{ env.ENV_FILE }}
          echo "DB_PASS=${{ secrets.DB_PASS }}" >> ${{ env.ENV_FILE }}
          echo "DB_NAME=auth_db" >> ${{ env.ENV_FILE }}
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> ${{ env.ENV_FILE }}
          echo "DB_HOST=db" >> ${{ env.ENV_FILE }}
          echo "REDIS_HOST=cache" >> ${{ env.ENV_FILE }}
          echo "REDIS_PORT=6379" >> ${{ env.ENV_FILE }}

      - name: Run Full Testing and Cleanup Sequence
        run: |
          echo "----------------------------------------------------"
          echo "ðŸš€ STARTING INFRASTRUCTURE..."
          echo "----------------------------------------------------"

          # 1. Start Docker containers (Builds the app image)
          docker compose --env-file .env.test up -d --build

          echo "â³ Waiting for Auth Service to launch..."

          RETRIES=0
          # Install curl for the health check
          sudo apt-get update && sudo apt-get install -y curl
          
          # 2. Wait for the Server (5s delay, 10 attempts = 50s max wait)
          until curl -s -o /dev/null "http://localhost:5000/api/auth/me" || [ $RETRIES -eq 10 ]; do
            sleep 5
            ((RETRIES++))
            echo -n "."
          done
          echo "" 

          if [ $RETRIES -eq 10 ]; then
              echo "âŒ Timeout waiting for Docker! Exiting."
              docker compose logs app
              exit 1
          fi

          echo "âœ… Docker is UP! Running Tests..."

          # 3. Execute the custom Python test script inside the 'app' container
          docker compose exec -T app sh -c "
            export PYTHONUNBUFFERED=1
            # --- EXECUTE CUSTOM PYTHON TEST SCRIPT ---
            python run_tests.py
          "
          TEST_EXIT_CODE=$?

          echo "----------------------------------------------------"
          echo "ðŸ§¹ CLEANING UP..."
          echo "----------------------------------------------------"

          # 4. Stop Containers (Uses the correct 'docker compose' syntax)
          docker compose down -v 2>/dev/null

          # 5. Check status (Final step before proceeding to deploy job)
          if [ $TEST_EXIT_CODE -eq 0 ]; then
              echo "âœ… SUCCESS: All tests passed. Proceeding to deploy."
          else
              echo "âŒ FAILURE: Some tests failed. Stopping deployment."
              exit 1
          fi
      
      - name: Login to Docker Hub
        if: success()
        uses: docker/login-action@v2
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      - name: Build and Push Final Image
        if: success()
        run: |
          echo "--- Pushing ${{ env.DOCKER_IMAGE_NAME }}:latest ---"
          # 1. Build the final image 
          docker build -t ${{ env.DOCKER_IMAGE_NAME }}:latest .
          
          # 2. Push to Docker Hub
          docker push ${{ env.DOCKER_IMAGE_NAME }}:latest

      - name: Final Cleanup (Safety Net)
        # This step is a safety net; the full cleanup should have happened inside the previous step.
        if: always()
        run: |
          docker compose down -v 2>/dev/null || true